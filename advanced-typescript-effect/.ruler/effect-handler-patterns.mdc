---
description:
globs: **/handlers/**/*.handler.ts,**/*-handler.ts
alwaysApply: false
---
# Effect-TS Handler Implementation Patterns and Best Practices

## Import Patterns

See `.rules/imports-and-conventions.md` for import and naming conventions.

## Usecase Co-location Pattern

### Usecases Must Be Co-located with Handlers
- **MANDATORY**: Place usecases in the same directory as their handlers
- **MANDATORY**: Place usecase tests in the same directory as the usecase
- This ensures clear ownership and easier maintenance

```
src/handlers/
├── jobs/
│   ├── get-job-by-id.handler.ts
│   ├── get-job-by-id.handler.test.ts
│   ├── get-jobs.handler.ts
│   └── get-jobs.handler.test.ts
└── media/
    ├── transcribe-workflow.handler.ts
    └── transcribe-workflow.handler.test.ts
```

### Usecase Import Pattern
```typescript
// ✅ CORRECT - Co-located usecase import
import { getBlogByIdUsecase } from './get-blog-by-id.usecase.js'

// ❌ WRONG - Separate usecases directory
import { getBlogByIdUsecase } from '../../usecases/get-blog-by-id.usecase.js'
```

## Handler Structure Pattern

### Standard REST API Handler
```typescript
/**
 * JSDoc description of the endpoint
 * HTTP_METHOD /api/path
 */
export const _handler = schemaInputMethod(InputSchema).pipe(
  Effect.flatMap(usecaseFunction),
  Effect.flatMap(responseFunction),
  Effect.tapError(Effect.logError),
  Effect.catchTags({
    ParseError: (error) => badRequestResponse(error.message),
    NotFoundError: () => notFoundResponse(),
    ConflictError: (error) => conflictResponse(error.message),
  }),
  Effect.orDie,
  Effect.withSpan('handler-name'),
)

export const handler = _handler.pipe(
  Effect.provide(RequiredStore.Default),
  Effect.withSpan('handler-name-full'),
  toHandler,
)
```

### Handler with Co-located Usecase
```typescript
import { Effect } from 'effect'
import { KeyDecryptor } from '../../lib/index.js'
import { sendCustomMessageUsecase } from './send-custom-message.usecase.js'

export const _handler = (event: CustomEmailSenderTriggerEvent) =>
  Effect.gen(function* () {
    yield* Effect.logInfo('Handler started', { /* context */ })
    const result = yield* sendCustomMessageUsecase(event)
    yield* Effect.logInfo('Handler completed successfully')
    return result
  }).pipe(
    Effect.tapError(Effect.logError),
    Effect.withSpan('handler-name'),
    Effect.annotateLogs({ handler: 'handler-name' }),
  )
```

## Project Structure

### Handler Organization
- Handlers are organized by feature/domain
- Usecases are co-located with their handlers
- Tests are co-located with implementation

```
src/
├── config.ts
├── domain/
├── stores/
├── usecases/
├── handlers/
│   ├── jobs/
│   │   ├── get-job-by-id.handler.ts
│   │   └── get-jobs.handler.ts
│   └── media/
│       └── transcribe-workflow.handler.ts
└── server.ts
```

## Configuration Access in Handlers

### Environment Variables
- **NEVER** access environment variables directly in handlers
- **ALWAYS** use configuration from `config.ts` through services
- Configuration is injected through Effect's dependency system

```typescript
// ❌ WRONG - Direct environment access
const tableName = process.env.BLOG_TABLE

// ✅ CORRECT - Configuration through services
export const _handler = schemaInput(InputSchema).pipe(
  Effect.flatMap(usecase), // usecase accesses config through stores
  Effect.flatMap(okResponse),
  // ...
)

// Services handle configuration
export const handler = _handler.pipe(
  Effect.provide(BlogStore.Default), // BlogStore uses config.ts
  toHandler,
)
```

## Input Validation Patterns

### Path Parameters
```typescript
// Using predefined schema
export const _handler = schemaPathParams(IdSchema).pipe(
  Effect.flatMap(({ id }) => usecase(BlogPostId.make(id))),
  // ... rest of handler
)

// Custom path schema
const PathParamsSchema = Schema.Struct({
  slug: Schema.String,
  authorId: Schema.String,
})

export const _handler = schemaPathParams(PathParamsSchema).pipe(
  Effect.flatMap(({ slug, authorId }) =>
    usecase(Slug.make(slug), UserId.make(authorId))
  ),
  // ... rest of handler
)
```

### Query Parameters
```typescript
export const _handler = schemaQueryParams(GetBlogPageInput).pipe(
  Effect.flatMap(getBlogPageUsecase),
  // ... rest of handler
)

// With error handling options
export const _handler = schemaQueryParams(SearchParamsSchema, {
  errors: 'all',
}).pipe(
  Effect.flatMap(searchUsecase),
  // ... rest of handler
)
```

### Request Body
```typescript
export const _handler = schemaBodyJson(CreateBlogPostInput).pipe(
  Effect.flatMap(createBlogPostUsecase),
  Effect.flatMap(createdResponse),
  // ... rest of handler
)
```

## Response Patterns

### Success Responses
```typescript
// 200 OK with data
Effect.flatMap(okResponse)

// 201 Created with data
Effect.flatMap(createdResponse)

// 204 No Content (for void operations)
Effect.asVoid,
Effect.flatMap(okResponse)

// 204 Deleted
Effect.flatMap(deletedResponse)
```

### Error Response Mapping
```typescript
Effect.catchTags({
  // 400 Bad Request
  ParseError: (error) => badRequestResponse(error.message),

  // 404 Not Found
  NotFoundError: () => notFoundResponse(),
  NotFoundError: (error) => notFoundResponse(error.message),

  // 409 Conflict
  ConflictError: (error) => conflictResponse(error.message),
})
```

## Service Dependency Injection

### Single Service
```typescript
export const handler = _handler.pipe(
  Effect.provide(BlogStore.Default),
  toHandler,
)
```

### Multiple Services
```typescript
export const handler = _handler.pipe(
  Effect.provide(BlogStore.Default),
  Effect.provide(SearchStore.Default),
  Effect.provide(AlgoliaLive),
  toHandler,
)
```

## Error Handling Patterns

### Standard Error Handling
```typescript
export const _handler = schemaInput(InputSchema).pipe(
  Effect.flatMap(usecase),
  Effect.flatMap(okResponse),
  Effect.tapError(Effect.logError),           // Always log errors
  Effect.catchTags({                     // Map domain errors to HTTP responses
    ParseError: (error) => badRequestResponse(error.message),
    NotFoundError: () => notFoundResponse(),
  }),
  Effect.orDie,                          // Crash on unhandled errors
  Effect.withSpan('handler-name'),       // Add tracing span
)
```
